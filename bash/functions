#!/bin/bash

# Always list directory contents upon 'cd'
function cd() {
    builtin cd "$@" || exit
    ll
}

# Call mv without the second parameter,
# it will prompt you to edit the filename on command line.
# Original mv is called when it's called with more than one argument.
function mv() {
    if [ "$#" -ne 1 ] || [ ! -e "$1" ]; then
        command mv -iv "$@"
        return
    fi

    read -r -ei "$1" newfilename
    command mv -iv -- "$1" "$newfilename"
}

# Makes new Dir and jumps inside
function cdmk() {
    mkdir -p "$@" && cd "$@" || exit
}

# Fuzzy find file
function ff() {
    find . -type f -iname "*$1*"
}

# Fuzzy find directory
function fd() {
    find . -type d -iname "*$1*"
}

#`v` with no arguments opens the current directory in vim,
# otherwise opens the given location
function v() {
   if [ $# -eq 0 ]; then
       vim .
   else
       vim "$@"
   fi
}

# `o` with no arguments opens the current directory,
# otherwise opens the given location
function o() {
    if [ $# -eq 0 ]; then
        open .
    else
        open "$@"
    fi
}

# search and replace with ag
function agr {
    ag -0 -l "$1" | xargs -0 perl -pi.bak -e "s/$1/$2/g"
}

# get colors in manual pages
function man() {
    LESS_TERMCAP_mb=$(printf "\e[1;31m") \
    LESS_TERMCAP_md=$(printf "\e[1;31m") \
    LESS_TERMCAP_me=$(printf "\e[0m") \s
    LESS_TERMCAP_se=$(printf "\e[0m") \
    LESS_TERMCAP_so=$(printf "\e[1;44;33m") \
    LESS_TERMCAP_ue=$(printf "\e[0m") \
    LESS_TERMCAP_us=$(printf "\e[1;32m") \
    /usr/bin/man "$@"
}

# syntax highligh in cat
function cat() {
    local out colored
    out=$(/bin/cat "$@")
    colored=$(echo "$out" | pygmentize -f console -g 2>/dev/null)
    [[ -n $colored ]] && echo "$colored" || echo "$out"
}

# list git repos status
function git-ls() {
    local directories
    directories=$(find . -maxdepth 1 -mindepth 1 -type d -printf '%f\n' | sort)
    for directory in $directories
        do
            local repo_name=${directory%%/}
            local repo_path
            repo_path=$(readlink -f "$repo_name")

            local branch
            branch=$(git -C "$repo_path" branch --no-color 2>/dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/\1/')

            if [[ -n $branch ]]; then
                local state
                state=$(git-status "$repo_path")

                if [ -n "$state" ]; then
                    local color="\033[1;31m"  # bold red
                else
                    local color="\033[1;37m"  # bold white
                fi

                echo -e "$repo_name: \x01$color\x02($branch$state)\x01\033[00m\x02"  # last bit resets color
            fi
        done
}

# Outputs a series of indicators based on the status of the working directory:
# + changes are staged and ready to commit
# * unstaged changes are present
# % untracked files are present
# B local branch is behind remote
# $ changes have been stashed
# P local commits need to be pushed to the remote
function git-status() {
    local status
    status="$(git -C "$1" status -s -b 2>/dev/null)"
    local output=''

    grep -qE '^[MADRC]' <<<"$status" && output="$output+"
    grep -qE '^.[MD]' <<<"$status" && output="$output*"
    grep -qE '^\?\?' <<<"$status" && output="$output%"
    grep -qE 'behind' <<<"$status" && output="${output}B"
    # uncomment that to get stash info, it was slowing down gls_state function
    #[[ -n $(git -C $1 stash list) ]] && output="${output}$"

    [[ -n $(git -C "$1" log --branches --not --remotes) ]] && output="${output}P"
    [[ -n $output ]] && output="|$output"  # separate from branch name

    echo "$output"
}

function docker-prune-images() {
    docker rmi -f "$(docker images -f dangling=true -q --no-trunc)"
}

function docker-prune-all() {
    docker system prune -a -f --volumes
}

function docker-volume-data() {
    if [ -z "$1" ]; then
        echo "No volume supplied."
        docker volume ls
    else
        docker volume inspect --format '{{ .Mountpoint }}' "$1"
    fi
}
